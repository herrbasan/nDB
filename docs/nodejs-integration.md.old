# nDB Node.js Integration Guide

> **Version:** 0.1.0  
> **Last Updated:** 2026-02-15  
> **Note:** TypeScript definitions are provided for TS users, but all examples use plain JavaScript.

---

## Table of Contents

1. [Overview](#overview)
2. [Integration Approaches](#integration-approaches)
3. [Recommended: N-API (napi-rs)](#recommended-n-api-napi-rs)
4. [Alternative: WebAssembly (WASM)](#alternative-webassembly-wasm)
5. [Alternative: gRPC Service](#alternative-grpc-service)
6. [Performance Comparison](#performance-comparison)
7. [TypeScript Support](#typescript-support)
8. [Deployment & Distribution](#deployment--distribution)
9. [Best Practices](#best-practices)
10. [Troubleshooting](#troubleshooting)

---

## Overview

This guide covers three ways to integrate nDB into Node.js projects. Since nDB is a Rust library, we provide multiple integration options to suit different deployment scenarios.

### Three Official Integration Approaches

| Approach | Performance | Best For |
|----------|-------------|----------|
| **N-API (napi-rs)** | Native speed | Production Node.js servers, maximum performance |
| **WebAssembly (WASM)** | ~80-90% native | Browser/Edge environments, no native dependencies |
| **gRPC Service** | Network overhead | Multi-language stacks, distributed systems |

All three approaches are officially supported. Choose based on your deployment constraints.

**Quick Decision:**
- Building a Node.js API server? → **N-API**
- Need browser/Edge compatibility? → **WASM**
- Using multiple languages? → **gRPC**

### All Approaches Are First-Class

All three integration methods are **officially supported and maintained**:

| Feature | N-API | WASM | gRPC |
|---------|-------|------|------|
| Actively maintained | ✅ | ✅ | ✅ |
| Full API coverage | ✅ | ⚠️ (in-memory only) | ✅ |
| Production-ready | ✅ | ✅ | ✅ |
| Plain JS support | ✅ | ✅ | ✅ |
| TypeScript definitions | ✅ | ✅ | ✅ |

Choose based on your constraints—not because one is "more official" than others.

---

## Integration Approaches

### Decision Flowchart

```
┌─────────────────────────────────────────────────────────────┐
│  Do you need native performance and file system access?     │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              ▼                               ▼
            YES                              NO
              │                               │
              ▼                               ▼
    ┌──────────────────────┐      ┌──────────────────────┐
    │ Use N-API (napi-rs)  │      │ Browser/Edge env?    │
    │ ━━━━━━━━━━━━━━━━━━━  │      └──────────────────────┘
    │ • Full SIMD support  │                  │
    │ • Memory-mapped I/O  │       ┌──────────┴──────────┐
    │ • Zero-copy ops      │       ▼                     ▼
    └──────────────────────┘     YES                    NO
                                          │               │
                                          ▼               ▼
                                ┌──────────────┐  ┌──────────────┐
                                │ Use WASM     │  │ Use gRPC     │
                                │ ━━━━━━━━━━   │  │ ━━━━━━━━━━   │
                                │ • Portable   │  │ • Multi-lang │
                                │ • Sandboxed  │  │ • Network    │
                                └──────────────┘  └──────────────┘
```

---

## JavaScript-First Philosophy

All nDB Node.js bindings are **built for plain JavaScript first**. TypeScript definitions are provided as a courtesy for teams that use TS, but:

- ✅ No build step required
- ✅ No type annotations in your code
- ✅ Works with CommonJS (`require`)
- ✅ Works with ES modules (`import`)
- ✅ Full IntelliSense via JSDoc (VS Code, WebStorm, etc.)

If you prefer TypeScript, type definitions are available via `@types/ndb-node` or included in the package.

---

## Recommended: N-API (napi-rs)

[N-API](https://nodejs.org/api/n-api.html) is Node.js's native addon API. [napi-rs](https://napi.rs/) is a Rust framework that makes building N-API modules ergonomic and safe.

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Node.js Process                          │
│  ┌─────────────────┐      ┌──────────────────────────────┐ │
│  │   Your JS Code  │◄────►│   ndb.node (N-API addon)     │ │
│  │                 │      │   ┌────────────────────────┐ │ │
│  │  const db =     │      │   │ napi-rs bindings       │ │ │
│  │    new NDB()    │      │   │ ━━━━━━━━━━━━━━━━━━━━━  │ │ │
│  │                 │      │   │ • Type conversions     │ │ │
│  │  db.search(...) │      │   │ • Async handling       │ │ │
│  │                 │      │   │ • Error mapping        │ │ │
│  └─────────────────┘      │   └────────────────────────┘ │ │
│                           │              │                 │
│                           │   ┌──────────┴──────────┐     │
│                           │   ▼                     ▼     │
│                           │ ┌────────────┐    ┌─────────┐ │
│                           │ │ ndb crate  │    │  std    │ │
│                           │ │ ━━━━━━━━━  │    │  libs   │ │
│                           │ │ • Database │    │         │ │
│                           │ │ • Search   │    │         │ │
│                           │ │ • HNSW     │    │         │ │
│                           │ └────────────┘    └─────────┘ │
│                           └──────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                 Operating System                            │
│        ┌──────────────────────────────────────┐             │
│        │    Memory-Mapped Files (mmap)        │             │
│        │    • Zero-copy reads                 │             │
│        │    • Instant recovery                │             │
│        └──────────────────────────────────────┘             │
└─────────────────────────────────────────────────────────────┘
```

### Project Structure

```
ndb-node/
├── Cargo.toml              # Rust dependencies
├── package.json            # Node.js package
├── build.rs                # Build configuration
├── src/
│   └── lib.rs              # N-API bindings
├── index.d.ts              # TypeScript definitions
├── index.js                # JS entry point
└── __test__/
    └── index.spec.mjs      # Tests
```

### Step 1: Create the N-API Package

```bash
# Install napi-rs CLI
npm install -g @napi-rs/cli

# Create new project
napi new ndb-node
cd ndb-node

# Install dependencies
npm install
```

### Step 2: Configure Cargo.toml

```toml
[package]
name = "ndb-node"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
# N-API dependencies
napi = { version = "2.14", default-features = false, features = ["napi8", "async"] }
napi-derive = "2.14"

# nDB dependency (path or git)
ndb = { path = "../ndb" }

# Async runtime for Node.js integration
tokio = { version = "1.35", features = ["rt-multi-thread"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[build-dependencies]
napi-build = "2.1"
```

### Step 3: Implement the Bindings

```rust
// src/lib.rs
use napi::bindgen_prelude::*;
use napi_derive::napi;
use std::sync::Arc;

use ndb::{
    Database, CollectionConfig, Collection, Document, 
    Search, Distance, Filter, Durability
};

// ============================================================================
// Database Wrapper
// ============================================================================

#[napi]
pub struct NDB {
    inner: Arc<Database>,
}

#[napi]
impl NDB {
    #[napi(constructor)]
    pub fn new(path: String) -> Result<Self> {
        let db = Database::open(&path)
            .map_err(|e| Error::from_reason(format!("Failed to open database: {}", e)))?;
        
        Ok(Self { 
            inner: db 
        })
    }

    #[napi]
    pub fn create_collection(
        &self,
        name: String,
        dim: u32,
        durability: Option<String>,
    ) -> Result<NDBCollection> {
        let durability = match durability.as_deref() {
            Some("sync") => Durability::FdatasyncEachBatch,
            _ => Durability::Buffered,
        };

        let config = CollectionConfig {
            dim: dim as usize,
            durability,
        };

        let collection = self.inner.create_collection(&name, config)
            .map_err(|e| Error::from_reason(format!("Failed to create collection: {}", e)))?;

        Ok(NDBCollection {
            inner: collection,
        })
    }

    #[napi]
    pub fn get_collection(&self, name: String) -> Result<NDBCollection> {
        let collection = self.inner.get_collection(&name)
            .map_err(|e| Error::from_reason(format!("Failed to get collection: {}", e)))?;

        Ok(NDBCollection { inner: collection })
    }

    #[napi]
    pub fn list_collections(&self) -> Vec<String> {
        self.inner.list_collections()
    }
}

// ============================================================================
// Collection Wrapper
// ============================================================================

#[napi]
pub struct NDBCollection {
    inner: Collection,
}

#[napi]
impl NDBCollection {
    #[napi]
    pub fn insert(
        &self,
        id: String,
        vector: Vec<f32>,
        payload: Option<String>,
    ) -> Result<()> {
        let payload = match payload {
            Some(json) => Some(serde_json::from_str(&json)
                .map_err(|e| Error::from_reason(format!("Invalid JSON payload: {}", e)))?),
            None => None,
        };

        let doc = Document {
            id,
            vector,
            payload,
        };

        self.inner.insert(doc)
            .map_err(|e| Error::from_reason(format!("Insert failed: {}", e)))?;

        Ok(())
    }

    #[napi]
    pub fn insert_batch(
        &self,
        documents: Vec<NDBDocumentInput>,
    ) -> Result<()> {
        let docs: Vec<Document> = documents
            .into_iter()
            .map(|d| Document {
                id: d.id,
                vector: d.vector,
                payload: d.payload.and_then(|json| serde_json::from_str(&json).ok()),
            })
            .collect();

        self.inner.insert_batch(docs)
            .map_err(|e| Error::from_reason(format!("Batch insert failed: {}", e)))?;

        Ok(())
    }

    #[napi]
    pub fn get(&self, id: String) -> Result<Option<NDBDocument>> {
        match self.inner.get(&id) {
            Ok(Some(doc)) => Ok(Some(NDBDocument {
                id: doc.id,
                vector: doc.vector,
                payload: doc.payload.map(|p| p.to_string()),
            })),
            Ok(None) => Ok(None),
            Err(e) => Err(Error::from_reason(format!("Get failed: {}", e))),
        }
    }

    #[napi]
    pub fn delete(&self, id: String) -> Result<bool> {
        self.inner.delete(&id)
            .map_err(|e| Error::from_reason(format!("Delete failed: {}", e)))
    }

    #[napi]
    pub fn search(&self, options: NDBSearchOptions) -> Result<Vec<NDBMatch>> {
        let mut search = Search::new(&options.vector)
            .top_k(options.top_k as usize);

        // Set distance metric
        if let Some(metric) = options.distance {
            search = search.distance(match metric.as_str() {
                "dot" => Distance::DotProduct,
                "euclidean" => Distance::Euclidean,
                _ => Distance::Cosine,
            });
        }

        // Enable approximate search
        if options.approximate.unwrap_or(false) {
            search = search.approximate(true);
        }

        // Set ef parameter
        if let Some(ef) = options.ef {
            search = search.ef(ef as usize);
        }

        // Apply filter if provided
        if let Some(filter_json) = options.filter {
            let filter = parse_filter(&filter_json)
                .map_err(|e| Error::from_reason(format!("Invalid filter: {}", e)))?;
            search = search.filter(filter);
        }

        let results = self.inner.search(&search)
            .map_err(|e| Error::from_reason(format!("Search failed: {}", e)))?;

        Ok(results.into_iter().map(|m| NDBMatch {
            id: m.id,
            score: m.score,
            payload: m.payload.map(|p| p.to_string()),
        }).collect())
    }

    #[napi]
    pub fn flush(&self) -> Result<()> {
        self.inner.flush()
            .map_err(|e| Error::from_reason(format!("Flush failed: {}", e)))
    }

    #[napi]
    pub fn compact(&self) -> Result<NDBCompactionResult> {
        let result = self.inner.compact()
            .map_err(|e| Error::from_reason(format!("Compact failed: {}", e)))?;

        Ok(NDBCompactionResult {
            docs_before: result.docs_before as u32,
            docs_after: result.docs_after as u32,
            segments_merged: result.segments_merged as u32,
            index_rebuilt: result.index_rebuilt,
        })
    }

    #[napi]
    pub fn rebuild_index(&self) -> Result<()> {
        self.inner.rebuild_index()
            .map_err(|e| Error::from_reason(format!("Index rebuild failed: {}", e)))
    }

    #[napi]
    pub fn delete_index(&self) -> Result<()> {
        self.inner.delete_index()
            .map_err(|e| Error::from_reason(format!("Index deletion failed: {}", e)))
    }

    #[napi]
    pub fn has_index(&self) -> bool {
        self.inner.has_index()
    }

    #[napi]
    pub fn sync(&self) -> Result<()> {
        self.inner.sync()
            .map_err(|e| Error::from_reason(format!("Sync failed: {}", e)))
    }

    #[napi(getter)]
    pub fn name(&self) -> String {
        self.inner.name().to_string()
    }

    #[napi(getter)]
    pub fn config(&self) -> NDBCollectionConfig {
        let config = self.inner.config();
        NDBCollectionConfig {
            dim: config.dim as u32,
            durability: match config.durability {
                Durability::Buffered => "buffered".to_string(),
                Durability::FdatasyncEachBatch => "sync".to_string(),
            },
        }
    }
}

// ============================================================================
// Data Types
// ============================================================================

#[napi(object)]
pub struct NDBDocumentInput {
    pub id: String,
    pub vector: Vec<f32>,
    pub payload: Option<String>,
}

#[napi(object)]
pub struct NDBDocument {
    pub id: String,
    pub vector: Vec<f32>,
    pub payload: Option<String>,
}

#[napi(object)]
pub struct NDBSearchOptions {
    pub vector: Vec<f32>,
    pub top_k: u32,
    pub distance: Option<String>,
    pub approximate: Option<bool>,
    pub ef: Option<u32>,
    pub filter: Option<String>,
}

#[napi(object)]
pub struct NDBMatch {
    pub id: String,
    pub score: f32,
    pub payload: Option<String>,
}

#[napi(object)]
pub struct NDBCollectionConfig {
    pub dim: u32,
    pub durability: String,
}

#[napi(object)]
pub struct NDBCompactionResult {
    pub docs_before: u32,
    pub docs_after: u32,
    pub segments_merged: u32,
    pub index_rebuilt: bool,
}

// ============================================================================
// Filter Parsing
// ============================================================================

fn parse_filter(json: &str) -> Result<Filter> {
    let value: serde_json::Value = serde_json::from_str(json)
        .map_err(|e| Error::from_reason(format!("Invalid JSON: {}", e)))?;

    parse_filter_value(&value)
        .ok_or_else(|| Error::from_reason("Invalid filter structure".to_string()))
}

fn parse_filter_value(value: &serde_json::Value) -> Option<Filter> {
    let obj = value.as_object()?;
    
    // Handle $and
    if let Some(serde_json::Value::Array(conds)) = obj.get("$and") {
        let filters: Vec<Filter> = conds.iter()
            .filter_map(parse_filter_value)
            .collect();
        return Some(Filter::and(filters));
    }
    
    // Handle $or
    if let Some(serde_json::Value::Array(conds)) = obj.get("$or") {
        let filters: Vec<Filter> = conds.iter()
            .filter_map(parse_filter_value)
            .collect();
        return Some(Filter::or(filters));
    }
    
    // Handle field conditions
    for (field, condition) in obj {
        if let Some(cond_obj) = condition.as_object() {
            for (op, val) in cond_obj {
                return match op.as_str() {
                    "$eq" => Some(Filter::eq(field, json_to_filter_value(val)?)),
                    "$ne" => Some(Filter::ne(field, json_to_filter_value(val)?)),
                    "$gt" => Some(Filter::gt(field, json_to_filter_value(val)?)),
                    "$gte" => Some(Filter::gte(field, json_to_filter_value(val)?)),
                    "$lt" => Some(Filter::lt(field, json_to_filter_value(val)?)),
                    "$lte" => Some(Filter::lte(field, json_to_filter_value(val)?)),
                    "$in" => {
                        let arr = val.as_array()?;
                        let values: Vec<_> = arr.iter()
                            .filter_map(json_to_filter_value)
                            .collect();
                        Some(Filter::in_(field, values))
                    }
                    _ => None,
                };
            }
        }
    }
    
    None
}

fn json_to_filter_value(value: &serde_json::Value) -> Option<ndb::filter::FilterValue> {
    match value {
        serde_json::Value::String(s) => Some(ndb::filter::FilterValue::String(s.clone())),
        serde_json::Value::Number(n) => {
            if let Some(i) = n.as_i64() {
                Some(ndb::filter::FilterValue::Int(i))
            } else if let Some(f) = n.as_f64() {
                Some(ndb::filter::FilterValue::Float(f))
            } else {
                None
            }
        }
        serde_json::Value::Bool(b) => Some(ndb::filter::FilterValue::Bool(*b)),
        _ => None,
    }
}
```

### Step 4: TypeScript Definitions

```typescript
// index.d.ts

export interface NDBDocumentInput {
  id: string;
  vector: number[];
  payload?: string;
}

export interface NDBDocument {
  id: string;
  vector: number[];
  payload?: string;
}

export interface NDBSearchOptions {
  vector: number[];
  topK: number;
  distance?: 'cosine' | 'dot' | 'euclidean';
  approximate?: boolean;
  ef?: number;
  filter?: string;
}

export interface NDBMatch {
  id: string;
  score: number;
  payload?: string;
}

export interface NDBCollectionConfig {
  dim: number;
  durability: 'buffered' | 'sync';
}

export interface NDBCompactionResult {
  docsBefore: number;
  docsAfter: number;
  segmentsMerged: number;
  indexRebuilt: boolean;
}

export class NDBCollection {
  readonly name: string;
  readonly config: NDBCollectionConfig;
  
  insert(id: string, vector: number[], payload?: string): void;
  insertBatch(documents: NDBDocumentInput[]): void;
  get(id: string): NDBDocument | null;
  delete(id: string): boolean;
  search(options: NDBSearchOptions): NDBMatch[];
  flush(): void;
  compact(): NDBCompactionResult;
  rebuildIndex(): void;
  deleteIndex(): void;
  hasIndex(): boolean;
  sync(): void;
}

export class NDB {
  constructor(path: string);
  
  createCollection(
    name: string, 
    dim: number, 
    durability?: 'buffered' | 'sync'
  ): NDBCollection;
  
  getCollection(name: string): NDBCollection;
  listCollections(): string[];
}
```

### Step 5: JavaScript Wrapper (Optional but Recommended)

The native addon exposes low-level bindings. This wrapper provides a cleaner JavaScript API with JSDoc for IDE support.

```javascript
// index.js - Plain JavaScript with JSDoc for IntelliSense
const { NDB, NDBCollection } = require('./ndb.node');

/**
 * @typedef {Object} Document
 * @property {string} id - Document ID
 * @property {number[]} vector - Embedding vector
 * @property {Object} [payload] - Optional metadata
 */

/**
 * @typedef {Object} SearchOptions
 * @property {number[]} vector - Query vector
 * @property {number} [topK=10] - Number of results
 * @property {'cosine'|'dot'|'euclidean'} [distance='cosine'] - Distance metric
 * @property {boolean} [approximate=false] - Use HNSW
 * @property {number} [ef] - HNSW search quality
 * @property {Object} [filter] - Metadata filter
 */

/**
 * Vector Database wrapper for nDB.
 * Works with plain JavaScript - no TypeScript required.
 */
class Database {
  constructor(path) {
    this._db = new NDB(path);
  }

  createCollection(name, dim, options = {}) {
    const durability = options.durability || 'buffered';
    return this._db.createCollection(name, dim, durability);
  }

  getCollection(name) {
    return this._db.getCollection(name);
  }

  listCollections() {
    return this._db.listCollections();
  }
}

// Helper for filter building
class FilterBuilder {
  /**
   * Create an equality filter
   * @param {string} field - Field name
   * @param {*} value - Value to match
   * @returns {Object} Filter object
   */
  static eq(field, value) {
    return { [field]: { $eq: value } };
  }

  static gt(field, value) {
    return { [field]: { $gt: value } };
  }

  static gte(field, value) {
    return { [field]: { $gte: value } };
  }

  static lt(field, value) {
    return { [field]: { $lt: value } };
  }

  static lte(field, value) {
    return { [field]: { $lte: value } };
  }

  static ne(field, value) {
    return { [field]: { $ne: value } };
  }

  static in(field, values) {
    return { [field]: { $in: values } };
  }

  static and(...filters) {
    return { $and: filters };
  }

  static or(...filters) {
    return { $or: filters };
  }
}

module.exports = {
  Database,
  FilterBuilder,
  NDB,
  NDBCollection
};
```

### Step 6: Usage Example (Plain JavaScript)

```javascript
// example.js
const { Database, FilterBuilder } = require('ndb-node');

async function main() {
  // Open database
  const db = new Database('./data');

  // Create collection for OpenAI embeddings (1536-dim)
  // Options are plain JavaScript objects - no types needed
  const collection = db.createCollection('documents', 1536, {
    durability: 'sync'  // or 'buffered'
  });

  // Insert documents
  const documents = [
    {
      id: 'doc1',
      vector: new Array(1536).fill(0.1),
      payload: JSON.stringify({ title: 'Introduction', category: 'docs' })
    },
    {
      id: 'doc2', 
      vector: new Array(1536).fill(0.2),
      payload: JSON.stringify({ title: 'API Guide', category: 'docs' })
    },
    {
      id: 'doc3',
      vector: new Array(1536).fill(0.3),
      payload: JSON.stringify({ title: 'Blog Post', category: 'blog' })
    }
  ];

  collection.insertBatch(documents);

  // Flush to segment
  collection.flush();

  // Build HNSW index for fast search
  collection.rebuildIndex();

  // Search with filter
  const query = new Array(1536).fill(0.15);
  
  const filter = FilterBuilder.eq('category', 'docs');
  
  const results = collection.search({
    vector: query,
    topK: 5,
    distance: 'cosine',
    approximate: true,
    ef: 64,
    filter: JSON.stringify(filter)
  });

  console.log('Search results:');
  for (const match of results) {
    const payload = JSON.parse(match.payload);
    console.log(`  ${match.id}: ${match.score.toFixed(4)} - ${payload.title}`);
  }

  // Get document by ID
  const doc = collection.get('doc1');
  console.log('Retrieved:', doc);

  // Delete document
  const deleted = collection.delete('doc2');
  console.log('Deleted:', deleted);

  // Compact to reclaim space
  const compactResult = collection.compact();
  console.log('Compacted:', compactResult);
}

main().catch(console.error);
```

### Step 7: Build & Package

```json
// package.json
{
  "name": "ndb-node",
  "version": "0.1.0",
  "main": "index.js",
  "types": "index.d.ts",
  "napi": {
    "name": "ndb-node",
    "triples": {
      "additional": [
        "aarch64-apple-darwin",
        "aarch64-linux-gnu",
        "x86_64-linux-gnu",
        "x86_64-apple-darwin",
        "x86_64-pc-windows-msvc"
      ]
    }
  },
  "scripts": {
    "build": "napi build --platform --release",
    "build:debug": "napi build --platform",
    "test": "node __test__/index.spec.mjs",
    "prepublishOnly": "napi prepublish -t npm"
  },
  "devDependencies": {
    "@napi-rs/cli": "^2.17.0"
  }
}
```

```bash
# Build native addon
npm run build

# Run tests
npm test

# Cross-compile for all platforms
npx napi build --platform --target x86_64-unknown-linux-gnu
npx napi build --platform --target aarch64-unknown-linux-gnu
npx napi build --platform --target x86_64-apple-darwin
npx napi build --platform --target aarch64-apple-darwin
npx napi build --platform --target x86_64-pc-windows-msvc
```

---

## Alternative: WebAssembly (WASM)

Use WASM when you need browser compatibility or simpler deployment without native dependencies.

**Limitations:**
- No memory-mapped file support (WASM sandbox)
- Limited SIMD performance
- Single-threaded (no threading support in WASM yet)

### Implementation with wasm-bindgen

```rust
// Cargo.toml
[package]
name = "ndb-wasm"
crate-type = ["cdylib", "rlib"]

[dependencies]
wasm-bindgen = "0.2"
ndb = { path = "../ndb" }
serde = { version = "1.0", features = ["derive"] }
serde-wasm-bindgen = "0.6"
js-sys = "0.3"
```

```rust
// src/lib.rs
use wasm_bindgen::prelude::*;
use ndb::{Database, CollectionConfig, Document, Search, Distance};

#[wasm_bindgen]
pub struct WasmDB {
    db: Database,
}

#[wasm_bindgen]
impl WasmDB {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Result<WasmDB, JsValue> {
        // In-memory only for WASM (no filesystem)
        let db = Database::open_in_memory()
            .map_err(|e| JsValue::from_str(&e.to_string()))?;
        Ok(WasmDB { db })
    }

    #[wasm_bindgen]
    pub fn search(&self, collection: &str, query: Vec<f32>, top_k: usize) -> Result<JsValue, JsValue> {
        let coll = self.db.get_collection(collection)
            .map_err(|e| JsValue::from_str(&e.to_string()))?;

        let search = Search::new(&query).top_k(top_k);
        let results = coll.search(&search)
            .map_err(|e| JsValue::from_str(&e.to_string()))?;

        serde_wasm_bindgen::to_value(&results)
            .map_err(|e| JsValue::from_str(&e.to_string()))
    }
}
```

```javascript
// usage in browser
import init, { WasmDB } from './pkg/ndb_wasm.js';

async function main() {
  await init();
  
  const db = new WasmDB();
  // ... use db
}
```

---

## Alternative: gRPC Service

Use a gRPC service when you need multi-language support or distributed access.

```proto
// ndb.proto
syntax = "proto3";

package ndb;

service NDBService {
  rpc Search(SearchRequest) returns (SearchResponse);
  rpc Insert(InsertRequest) returns (InsertResponse);
  rpc Get(GetRequest) returns (GetResponse);
}

message SearchRequest {
  string collection = 1;
  repeated float vector = 2;
  uint32 top_k = 3;
  bool approximate = 4;
}

message SearchResponse {
  repeated Match matches = 1;
}

message Match {
  string id = 1;
  float score = 2;
  string payload = 3;
}
```

```javascript
// client.js
const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');

const packageDefinition = protoLoader.loadSync('ndb.proto');
const ndbProto = grpc.loadPackageDefinition(packageDefinition).ndb;

const client = new ndbProto.NDBService(
  'localhost:50051',
  grpc.credentials.createInsecure()
);

// Search
client.search({
  collection: 'documents',
  vector: new Array(1536).fill(0.1),
  topK: 10,
  approximate: true
}, (err, response) => {
  console.log(response.matches);
});
```

---

## Performance Comparison

| Metric | N-API | WASM | gRPC (local) |
|--------|-------|------|--------------|
| **Search latency** (1M vectors) | <1ms | ~5ms | ~2ms |
| **Insert throughput** | 100K/s | 20K/s | 50K/s |
| **Memory overhead** | Minimal | ~2x | Minimal |
| **Startup time** | Fast | Medium | Slow |
| **File I/O** | Native mmap | In-memory only | Native mmap |
| **SIMD** | Full AVX2/AVX-512 | Partial (SIMD128) | Full |
| **Bundle size** | ~5MB | ~2MB | ~5MB + proto |

---

## TypeScript Support (Optional)

While nDB Node.js bindings are written in plain JavaScript, **TypeScript definitions are provided** for teams that use TypeScript. You don't need TypeScript to use nDB—everything works with plain JS.

### Installing Type Definitions

```bash
# TypeScript users
npm install --save-dev @types/ndb-node

# Plain JavaScript - no install needed, JSDoc provides IntelliSense
```

### Using JSDoc for IntelliSense (Plain JS)

Even without TypeScript, you can get full autocomplete and type checking in VS Code:

```javascript
// @ts-check directive enables type checking in plain JS files
// @ts-check

const { Database } = require('ndb-node');

/** @type {import('ndb-node').Database} */
const db = new Database('./data');

// Now you get autocomplete for all Database methods
db.  // <-- IntelliSense shows createCollection, getCollection, etc.
```

Or add to your `jsconfig.json`:
```json
{
  "compilerOptions": {
    "checkJs": true,
    "module": "commonjs",
    "target": "es2020"
  }
}
```

### Full Type Definitions

```typescript
// types/ndb.d.ts - For TypeScript users
declare module 'ndb-node' {
  export type DistanceMetric = 'cosine' | 'dot' | 'euclidean';
  export type Durability = 'buffered' | 'sync';

  export interface Document {
    id: string;
    vector: Float32Array | number[];
    payload?: Record<string, unknown>;
  }

  export interface SearchOptions {
    vector: Float32Array | number[];
    topK?: number;
    distance?: DistanceMetric;
    approximate?: boolean;
    ef?: number;
    filter?: Filter;
  }

  export interface Match {
    id: string;
    score: number;
    payload?: Record<string, unknown>;
  }

  export type Filter = 
    | { [field: string]: { $eq: unknown } }
    | { [field: string]: { $gt: number } }
    | { [field: string]: { $gte: number } }
    | { [field: string]: { $lt: number } }
    | { [field: string]: { $lte: number } }
    | { [field: string]: { $ne: unknown } }
    | { [field: string]: { $in: unknown[] } }
    | { $and: Filter[] }
    | { $or: Filter[] };

  export class Collection {
    readonly name: string;
    readonly dimension: number;

    insert(doc: Document): void;
    insertBatch(docs: Document[]): void;
    get(id: string): Document | null;
    delete(id: string): boolean;
    search(options: SearchOptions): Match[];
    
    flush(): void;
    compact(): { docsBefore: number; docsAfter: number };
    
    rebuildIndex(): void;
    deleteIndex(): void;
    hasIndex(): boolean;
  }

  export class Database {
    constructor(path: string);
    
    createCollection(
      name: string, 
      dimension: number, 
      options?: { durability?: Durability }
    ): Collection;
    
    getCollection(name: string): Collection;
    listCollections(): string[];
    
    close(): void;
  }

  export const FilterBuilder: {
    eq(field: string, value: unknown): Filter;
    gt(field: string, value: number): Filter;
    gte(field: string, value: number): Filter;
    lt(field: string, value: number): Filter;
    lte(field: string, value: number): Filter;
    ne(field: string, value: unknown): Filter;
    in(field: string, values: unknown[]): Filter;
    and(...filters: Filter[]): Filter;
    or(...filters: Filter[]): Filter;
  };
}
```

---

## Deployment & Distribution

### NPM Package Structure

```
ndb-node/
├── package.json
├── index.js              # Main entry
├── index.d.ts            # TypeScript types
├── README.md
├── LICENSE
└── npm/
    ├── darwin-arm64/
    │   └── ndb-node.node
    ├── darwin-x64/
    │   └── ndb-node.node
    ├── linux-arm64-gnu/
    │   └── ndb-node.node
    ├── linux-x64-gnu/
    │   └── ndb-node.node
    └── win32-x64-msvc/
        └── ndb-node.node
```

### GitHub Actions for CI/CD

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    strategy:
      matrix:
        target:
          - x86_64-pc-windows-msvc
          - x86_64-apple-darwin
          - aarch64-apple-darwin
          - x86_64-unknown-linux-gnu
          - aarch64-unknown-linux-gnu

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup Rust
        uses: dtolnay/rust-action@stable
        with:
          targets: ${{ matrix.target }}
      
      - name: Install dependencies
        run: npm install
      
      - name: Build
        run: npx napi build --platform --target ${{ matrix.target }}
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.target }}
          path: '*.node'

  publish:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: npm
      
      - name: Publish to NPM
        run: npx napi prepublish -t npm
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

---

## Best Practices

### 1. Connection Pooling

```javascript
const { Database } = require('ndb-node');

// Create database once, reuse across requests
const db = new Database(process.env.NDB_DATA_DIR);

// FastAPI-style (Express example)
app.get('/search', (req, res) => {
  const collection = db.getCollection('documents');
  const results = collection.search({
    vector: req.body.vector,
    topK: req.body.topK || 10
  });
  res.json(results);
});
```

### 2. Batch Operations

```javascript
// Bad: Individual inserts
for (const doc of documents) {
  collection.insert(doc.id, doc.vector, doc.payload);
}

// Good: Batch insert
collection.insertBatch(documents);
collection.flush();  // Flush after batch
```

### 3. Index Management

```javascript
// Build index after bulk load
collection.insertBatch(documents);
collection.flush();
collection.rebuildIndex();

// For incremental updates, periodic compaction
setInterval(() => {
  collection.compact();
}, 24 * 60 * 60 * 1000);  // Daily
```

### 4. Error Handling

```javascript
const { Database } = require('ndb-node');

class NDBClient {
  constructor(path) {
    this.db = new Database(path);
  }

  safeSearch(collectionName, query, options = {}) {
    try {
      const collection = this.db.getCollection(collectionName);
      return {
        success: true,
        results: collection.search({
          vector: query,
          topK: options.topK || 10,
          approximate: options.approximate ?? true
        })
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
}
```

### 5. Async Wrapper

```javascript
const { promisify } = require('util');

// Wrap sync operations for async/await compatibility
class AsyncCollection {
  constructor(collection) {
    this._collection = collection;
  }

  async search(options) {
    // Offload to worker thread for large searches
    return new Promise((resolve, reject) => {
      try {
        const results = this._collection.search(options);
        resolve(results);
      } catch (error) {
        reject(error);
      }
    });
  }
}
```

---

## Troubleshooting

### Issue: Module not found

```bash
# Error: Cannot find module './ndb.node'

# Solution: Rebuild for your platform
npm install
npm run build

# Or use prebuilt binaries
npm install ndb-node --target_arch=x64 --target_platform=linux
```

### Issue: Collection locked

```javascript
// Error: CollectionLocked

// Cause: Another process has the collection open
// Solution: Ensure only one writer per collection

// Check for orphaned lock files
const fs = require('fs');
const path = require('path');

const lockPath = path.join(dataDir, 'collection_name', 'LOCK');
if (fs.existsSync(lockPath)) {
  // Only remove if no process is using it
  console.warn('Lock file exists. Check if another process is running.');
}
```

### Issue: Slow search performance

```javascript
// Check if HNSW index exists
if (!collection.hasIndex()) {
  console.log('Building HNSW index...');
  collection.rebuildIndex();
}

// Use approximate search
collection.search({
  vector: query,
  topK: 10,
  approximate: true,  // Enable HNSW
  ef: 128             // Higher = better recall
});
```

### Issue: Memory usage too high

```javascript
// Compact collection to reclaim space
const result = collection.compact();
console.log(`Reduced from ${result.docsBefore} to ${result.docsAfter} documents`);

// Delete unused indexes
collection.deleteIndex();
```

---

## Appendix: API Reference

### Database

| Method | Description |
|--------|-------------|
| `new Database(path)` | Open or create database |
| `createCollection(name, dim, options)` | Create new collection |
| `getCollection(name)` | Get existing collection |
| `listCollections()` | List all collection names |

### Collection

| Method | Description |
|--------|-------------|
| `insert(id, vector, payload?)` | Insert single document |
| `insertBatch(documents)` | Batch insert |
| `get(id)` | Get document by ID |
| `delete(id)` | Delete document |
| `search(options)` | Search for similar vectors |
| `flush()` | Persist memtable to segment |
| `compact()` | Merge segments, rebuild index |
| `rebuildIndex()` | Build HNSW index |
| `deleteIndex()` | Remove HNSW index |
| `hasIndex()` | Check if index exists |
| `sync()` | Force WAL sync |

---

*For more information, see the [nDB documentation](https://github.com/ndb/ndb) or file an issue.*
